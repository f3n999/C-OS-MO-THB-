# Security Analysis of the `kmon` Kernel Module

## 1. Overview

The `kmon` kernel module is designed to monitor file access by hooking the `do_sys_openat2` kernel function using `kprobes`. Its primary purpose is to detect and log attempts to access the `/etc/shadow` file, which contains sensitive user password hashes.

This document outlines the potential security risks associated with this module and the measures taken to mitigate them.

## 2. Potential Attack Vectors & Mitigations

### 2.1. Kernel-Level Code Execution / Panic

**Risk:**
Any bug within a kernel module can be catastrophic, leading to a system crash (kernel panic) or, in the worst case, a security vulnerability that could be exploited for privilege escalation. Specific risks include:
- **Null Pointer Dereference:** If `kallsyms` fails to find the address of `do_sys_openat2`, the `kprobe.addr` would be NULL, causing a panic upon registration.
- **Buffer Overflow:** When copying the filename from user space, a simple `strcpy` could lead to a buffer overflow if the user-provided path is longer than the kernel buffer.

**Mitigation:**
- **Error Handling:** The `kmon_init` function explicitly checks the return value of `register_kprobe`. If registration fails (e.g., the symbol is not found), it returns an error code, preventing the module from loading in a faulty state.
- **Strict Compilation Flags:** The `Makefile` is configured with `-Wextra -Werror -fanalyzer -pedantic -std=c99`. This enforces a high standard of code quality, treating all warnings as errors and preventing the compilation of potentially unsafe code. The `-fanalyzer` flag enables GCC's static analysis to find potential issues at compile time.
- **Safe String Handling:** The `strncpy_from_user` function is used to copy the filename from user space to a fixed-size kernel buffer. This function is safer than `strcpy` because it includes a size limit (`sizeof(filename)`), preventing buffer overflows. It also handles faults if the user-space memory is invalid.

### 2.2. Information Disclosure

**Risk:**
The module logs the process name and PID of any process accessing `/etc/shadow`. This information is written to the kernel log buffer, which can be read via the `dmesg` command. If an unprivileged user can read these logs, it could reveal information about system activity (e.g., that a security audit is in progress).

**Mitigation:**
- **Restricted `dmesg` Access:** On modern Linux systems, access to `dmesg` is typically restricted to the `root` user by default (via the `dmesg_restrict=1` sysctl setting). This is a system-level configuration that we rely on to protect the log data. Our module does not change these permissions.
- **Controlled Logging:** The module's scope is intentionally narrow. It only logs access to the specific, predefined file (`/etc/shadow`). It does not log all file accesses, which minimizes the amount of potentially sensitive information being recorded.

### 2.3. Denial of Service (DoS)

**Risk:**
An attacker with local access could repeatedly and rapidly try to open `/etc/shadow`. This would trigger the kprobe handler for each attempt, potentially flooding the kernel logs (`dmesg`) and consuming CPU resources, leading to a system-wide slowdown or making the logs unusable.

**Mitigation:**
- **Minimal Probe Handler Logic:** The code within the `handler_pre` function is designed to be as efficient as possible. It performs a quick string copy and comparison.
- **Future Enhancement (Rate-Limiting):** For a production-level tool, a rate-limiting mechanism could be implemented. This would involve using a data structure (like a hash table of recent offenders) to track the frequency of access attempts from specific PIDs or users and suppressing log messages if a certain threshold is exceeded. This is not implemented in the current version for simplicity.

## 3. Assembly Code Analysis (`objdump`)

To demonstrate a deeper understanding of the compiled code and verify the compiler's output, we can analyze the assembly of the `kmon.o` object file.

**How to Perform the Analysis:**
1.  Navigate to the `src/` directory.
2.  Compile the module using the provided `Makefile`: `make`
3.  Use `objdump` to disassemble the compiled object file:
    ```bash
    objdump -d -S kmon.o
    ```

**What to Look For:**
- **Function Prologue/Epilogue:** Examine the `kmon_init` and `kmon_exit` functions to see how the stack frame is set up and torn down.
- **`handler_pre` Logic:**
    - Verify that the `regs->si` register (which holds the second argument, the filename pointer, on x86-64) is correctly accessed.
    - Inspect the call to `strncpy_from_user` and `strcmp` to see how they are translated into assembly.
    - Confirm there are no unexpected or inefficient instructions generated by the compiler.
- **Security:** Look for any potential vulnerabilities at the assembly level, such as incorrect use of registers or stack corruption, that might have been missed in the C code review. This low-level analysis is crucial for security-sensitive code like a kernel module.

By performing this analysis, we can gain confidence that the compiled code behaves as intended and does not introduce any unforeseen security risks.