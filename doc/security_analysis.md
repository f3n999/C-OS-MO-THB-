# Security Analysis of the `kmon` Kernel Module

## 1. Overview

The `kmon` kernel module is designed to monitor file access by dynamically placing kprobes on file-opening syscalls like `openat` and `openat2`. Its primary goal is to log attempts to access sensitive files, which are defined by a comma-separated list of keywords.

This document outlines potential security considerations and the mitigation strategies implemented in the module.

## 2. Potential Attack Vectors & Mitigations

### 2.1. Kernel-Level Code Execution / System Instability

**Risk:**
As a kernel module, any bug, such as a null pointer dereference or buffer overflow, can lead to a system-wide crash (kernel panic). An attacker could potentially exploit such a flaw to escalate privileges.

*   **Dangling Pointers/Memory Leaks:** If memory allocated with `kmalloc` is not freed, it can lead to memory leaks. If a kprobe handler accesses data that has already been freed, it can cause a crash.
*   **Buffer Overflows:** Copying data from user space (e.g., a filename) without proper size checks can overflow kernel buffers.

**Mitigation:**
*   **Safe Memory Management:** The `kmon_data` structure is allocated and freed for each system call via the `kretprobe` mechanism, minimizing the risk of use-after-free errors. The `match_buf` is allocated with `kstrdup` and freed in `kmon_exit`.
*   **Safe String Handling:** `strncpy_from_user` is used to copy filenames from user space. This function is designed to be safe, as it checks for valid user-space addresses and prevents buffer overflows by respecting the provided size limit.
*   **Error Handling:** The `kmon_init` function includes robust checks. It verifies the success of `register_kretprobe` and attempts to fall back to an alternative syscall if the primary one fails. If no probe can be placed, the module fails to load, preventing it from running in a faulty state.
*   **Strict Compilation Flags:** The `Makefile` uses `-Wextra` and `-Werror`, which turns a wide range of potential coding errors into compilation failures, enforcing a higher standard of code safety.

### 2.2. Information Disclosure

**Risk:**
The module logs the process name, PID, UID, GID, and the full path of accessed files to the kernel log buffer (`dmesg`). If an unprivileged user can read these logs, it could leak sensitive information about system activity or user actions.

**Mitigation:**
*   **Restricted `dmesg` Access:** By default, modern Linux kernels restrict access to `dmesg` to privileged users (root). The module relies on this standard OS-level security feature.
*   **Controlled Logging:** The module's logging is controlled by the `log_all=false` parameter by default, meaning it only logs accesses to files matching the `match` parameter. This reduces noise and potential information leaks.
*   **Optional Syslog Forwarding:** The `Makefile` provides a `persist` target that configures `rsyslog` to write `kmon` logs to a separate file (`/var/log/kmon.log`). File permissions on this log file can be further restricted to limit access.

### 2.3. Denial of Service (DoS)

**Risk:**
A malicious local user could trigger a high volume of `open` or `openat` calls on files containing the monitored keywords. This could flood the kernel log buffer, consuming significant CPU resources in the kprobe handler and potentially slowing down the entire system.

**Mitigation:**
*   **Minimal Probe Handler Logic:** The `entry_handler` and `ret_handler` functions are designed to be as lightweight as possible. They perform essential checks and data collection quickly and defer the more expensive string formatting and logging to the return path.
*   **Future Enhancement - Rate Limiting:** For a more robust production environment, a rate-limiting mechanism could be added. This would involve tracking the frequency of log messages per process and temporarily disabling logging for a specific process if it exceeds a defined threshold. This is not implemented in the current version to maintain simplicity.

## 4. Assembly Code Analysis (`objdump`)

A key part of understanding kernel-level code is to inspect the machine code generated by the compiler. This helps verify that the C code translates to the expected low-level operations.

**Command:**
```bash
objdump -d -S kmon.o
```

**What to Look For:**
1.  **Syscall Argument-Passing Convention:**
    *   For the `x86-64` architecture, arguments are passed via registers: `%rdi`, `%rsi`, `%rdx`, `%r10`, etc.
    *   The `get_user_filename` function correctly retrieves the filename pointer from the `%rsi` register for both `openat` and `openat2`.
    *   The `entry_openat` handler correctly reads flags from `%rdx` and mode from `%r10`.
    *   The `entry_openat2` handler correctly reads the `struct open_how` pointer from `%rdx`.
2.  **Function Calls:**
    *   Verify the calls to `strncpy_from_user`, `kstrdup`, `pr_info`, etc., are present and use the correct arguments.
3.  **Kernel/User Space Boundary:**
    *   The use of `strncpy_from_user` is critical. Examining its implementation in the assembly would show the necessary checks to prevent accessing invalid user memory.

This low-level analysis confirms the code's behavior and helps identify potential security vulnerabilities that might be missed at the source-code level.