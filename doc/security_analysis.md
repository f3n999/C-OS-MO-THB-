# Security Analysis of the `kmon` Kernel Module

## 1. Overview

The `kmon` kernel module is designed to monitor file access by hooking the `do_sys_openat2` or `__x86_64_sys_openat` system calls using `kprobes`. Its primary purpose is to detect and log attempts to access sensitive files, such as `/etc/shadow`. This document outlines the potential security risks associated with this module and the measures taken to mitigate them.

## 2. Potential Attack Vectors & Mitigations

### 2.1. Kernel-Level Code Execution / Panic

**Risk:**
Any bug within a kernel module can be catastrophic, leading to a system crash (kernel panic) or, in the worst case, a security vulnerability that could be exploited for privilege escalation. Specific risks include:
- **Null Pointer Dereference:** If `kallsyms` fails to find the address of the target symbol, the `kprobe.addr` would be NULL, causing a panic upon registration.
- **Buffer Overflow:** When copying the filename from user space, a simple `strcpy` could lead to a buffer overflow if the user-provided path is longer than the kernel buffer.

**Mitigation:**
- **Error Handling:** The `kmon_init` function explicitly checks the return value of `register_kprobe`. If registration fails, it attempts a fallback to another common syscall name (`__x86_64_sys_openat2` or `do_sys_openat`) before giving up. This increases robustness across different kernel versions. If all attempts fail, it returns an error, preventing the module from loading in a faulty state.
- **Strict Compilation Flags:** The `Makefile` is configured with `-Wextra -Werror -fanalyzer -pedantic -std=c99`. This enforces a high standard of code quality, treating all warnings as errors and preventing the compilation of potentially unsafe code. The `-fanalyzer` flag enables GCC's static analysis to find potential issues at compile time.
- **Safe String Handling:** The `strncpy_from_user` function is used to copy the filename from user space to a fixed-size kernel buffer. This function is safer than `strcpy` because it includes a size limit (`sizeof(path)`), preventing buffer overflows. It also handles faults if the user-space memory is invalid. The `strlcpy` function is used for copying the module parameters, which is a safer alternative to `strcpy`.

### 2.2. Information Disclosure

**Risk:**
The module logs the process name and PID of any process accessing sensitive files. This information is written to the kernel log buffer, which can be read via the `dmesg` command. If an unprivileged user can read these logs, it could reveal information about system activity.

**Mitigation:**
- **Restricted `dmesg` Access:** On modern Linux systems, access to `dmesg` is typically restricted to the `root` user by default (via the `dmesg_restrict=1` sysctl setting). This is a system-level configuration that we rely on to protect the log data.
- **Controlled Logging:** The module only logs access to files whose paths contain specific keywords (e.g., "passwd", "shadow"). It does not log all file access, minimizing the amount of potentially sensitive information being recorded.

### 2.3. Denial of Service (DoS)

**Risk:**
An attacker with local access could repeatedly and rapidly try to open files with names matching the monitored keywords. This would trigger the kprobe handler for each attempt, potentially flooding the kernel logs (`dmesg`) and consuming CPU resources, leading to a system-wide slowdown or making the logs unusable.

**Mitigation:**
- **Minimal Probe Handler Logic:** The code within the `handler_pre` function is designed to be as efficient as possible. It performs a quick string copy and comparison.
- **Future Enhancement (Rate-Limiting):** For a production-level tool, a rate-limiting mechanism could be implemented. This would involve using a data structure (like a hash table of recent offenders) to track the frequency of access attempts from specific PIDs or users and suppressing log messages if a certain threshold is exceeded. This is not implemented in the current version for simplicity.

## 4. Assembly Code Analysis (`objdump`)

To demonstrate a deeper understanding of the compiled code and verify the compiler's output, we can analyze the assembly of the `kmon.o` object file.

**How to Perform the Analysis:**
1.  Navigate to the project directory.
2.  Compile the module using the provided `Makefile`: `make`
3.  Use `objdump` to disassemble the compiled object file:
    ```bash
    objdump -d -S kmon.o
    ```

**What to Look For:**
- **Function Prologue/Epilogue:** Examine the `kmon_init` and `kmon_exit` functions to see how the stack frame is set up and torn down.
- **`handler_pre` Logic:**
    - Verify that the `regs->si` register (for x86_64) or `regs->regs[1]` (for arm64) is correctly accessed to get the filename pointer.
    - Inspect the call to `strncpy_from_user` and `strstr` to see how they are translated into assembly.
    - Confirm there are no unexpected or inefficient instructions generated by the compiler.
- **Security:** Look for any potential vulnerabilities at the assembly level, such as incorrect use of registers or stack corruption, that might have been missed in the C code review. This low-level analysis is crucial for security-sensitive code like a kernel module.

## 5. Conclusion

The `kmon` module, while simple, is designed with security in mind. By using strict compilation flags, safe memory handling functions, and a limited scope of operation, the primary risks are mitigated. Further enhancements, such as rate-limiting, could be added to improve its robustness against DoS attacks. The use of `kprobes` is a powerful but potentially risky technique, and careful implementation is essential for system stability.
The current implementation provides a solid foundation for a file access monitoring tool.